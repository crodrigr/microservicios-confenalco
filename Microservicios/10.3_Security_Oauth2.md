# Sring security con Oauth2

<br>

## 1. Spring security

Spring Security es un marco de seguridad poderoso y altamente personalizable dentro del ecosistema de Spring que proporciona funcionalidades de seguridad para aplicaciones web y aplicaciones basadas en servicios. Su objetivo principal es proteger los recursos de una aplicación contra accesos no autorizados y garantizar la autenticación y autorización adecuadas de los usuarios.

Las principales características y funcionalidades de Spring Security incluyen:

1. Autenticación: Spring Security ofrece diferentes métodos de autenticación, como autenticación basada en formularios, autenticación basada en tokens, autenticación LDAP, autenticación con proveedores externos (OAuth, SAML, etc.), entre otros.

2. Autorización: Proporciona mecanismos para definir reglas de autorización para restringir el acceso a recursos específicos de acuerdo con roles y permisos definidos.

3. Protección contra ataques de seguridad: Spring Security aborda problemas comunes de seguridad, como ataques CSRF (Cross-Site Request Forgery), XSS (Cross-Site Scripting), Clickjacking, etc.

4. Manejo de sesiones: Permite administrar sesiones de usuario y ofrece opciones para almacenarlas de diferentes maneras (por ejemplo, en la memoria, en la base de datos, etc.).

5. Soporte para múltiples proveedores de autenticación: Puedes integrar fácilmente proveedores de autenticación externos como Google, Facebook, GitHub, entre otros, utilizando módulos específicos de Spring Security.

6. Personalización y extensibilidad: Spring Security está altamente modularizado y permite personalizar y extender sus componentes para adaptarse a los requisitos específicos de seguridad de tu aplicación.

Para usar Spring Security en una aplicación Spring Boot, puedes agregar la dependencia `spring-boot-starter-security` en tu archivo de configuración (pom.xml si estás utilizando Maven o build.gradle si estás utilizando Gradle). Al hacerlo, Spring Boot configura automáticamente una serie de características de seguridad básicas para tu aplicación, incluida la protección de las rutas por defecto y la generación de una contraseña aleatoria para el usuario "user".

A partir de ahí, puedes personalizar la configuración de seguridad según tus necesidades, definiendo clases de configuración que extiendan `WebSecurityConfigurerAdapter` y anotándolas con `@EnableWebSecurity`. Dentro de estas clases, puedes definir reglas de autorización, mecanismos de autenticación personalizados y más.

Es importante tener en cuenta que la seguridad de una aplicación es un tema crítico y complejo. Es fundamental comprender bien las características de seguridad que se están implementando y seguir buenas prácticas de seguridad para garantizar que tu aplicación esté protegida contra posibles vulnerabilidades. La documentación oficial de Spring Security es una excelente fuente de información para aprender más sobre cómo implementar la seguridad en tus aplicaciones Spring.



<br>
<br>
<br>

## 2. Oauth2
Spring Boot es un marco de trabajo de Spring que permite desarrollar aplicaciones de manera rápida y sencilla. OAuth 2, por otro lado, es un protocolo de autorización utilizado para proteger recursos y permitir que aplicaciones de terceros accedan a recursos en nombre de un usuario.

Cuando se combinan Spring Boot y OAuth 2, se obtiene una potente plataforma para crear aplicaciones seguras y protegidas mediante el protocolo OAuth 2. Spring Security es la biblioteca de Spring que se utiliza para implementar la seguridad en las aplicaciones y también incluye soporte para OAuth 2.

En Spring Boot, puedes habilitar la seguridad OAuth 2 utilizando el módulo `spring-boot-starter-oauth2-client` o `spring-boot-starter-oauth2-resource-server`, dependiendo de si tu aplicación actúa como un cliente que consume recursos protegidos (como una aplicación web) o como un servidor de recursos que protege y proporciona acceso a recursos (como una API).

A continuación, te muestro una breve descripción de cada uno de estos módulos:

1. `spring-boot-starter-oauth2-client`: Este módulo es adecuado cuando tu aplicación actúa como un cliente y necesita interactuar con proveedores de autenticación externos (como Google, Facebook, etc.). Proporciona una configuración fácil para la autenticación OAuth 2.0 del lado del cliente.

2. `spring-boot-starter-oauth2-resource-server`: Este módulo es adecuado cuando tu aplicación actúa como un servidor de recursos y necesita proteger los endpoints y recursos expuestos por tu API. Proporciona una configuración fácil para proteger tus endpoints y validar los tokens de acceso proporcionados por los clientes autorizados.

Dependiendo de tus necesidades, deberás incluir uno de estos módulos en tu proyecto y configurar las propiedades y ajustes necesarios para implementar la seguridad OAuth 2. También deberás establecer las reglas de autorización y asegurarte de que los usuarios solo tengan acceso a los recursos para los que están autorizados.

Ten en cuenta que implementar correctamente la seguridad OAuth 2 puede ser un proceso complejo y crítico para la seguridad de tu aplicación, por lo que es recomendable consultar la documentación oficial de Spring Security y OAuth 2, y seguir buenas prácticas de seguridad en el desarrollo de tu aplicación.

## 3. Jwt

JWT (JSON Web Token) es un estándar abierto (RFC 7519) que define un formato compacto y seguro para transmitir información entre dos partes en forma de objetos JSON. Está diseñado para ser utilizado en sistemas distribuidos y aplicaciones web para proporcionar autenticación y autorización sin la necesidad de almacenar información de estado en el servidor.

Un JWT consta de tres partes separadas por puntos:

1. Encabezado (Header): Es un objeto JSON que contiene información sobre el tipo de token (JWT) y el algoritmo de firma utilizado. El encabezado típicamente se ve así:
   ```
   {
     "alg": "HS256",
     "typ": "JWT"
   }
   ```

2. Cuerpo (Payload): Es un objeto JSON que contiene la información que se quiere transmitir. Puede incluir datos como el identificador del usuario, roles, permisos, etc. Algunos campos predefinidos son "sub" (sujeto), "iss" (emisor), "exp" (tiempo de expiración), "iat" (tiempo de emisión), entre otros. También es posible incluir campos personalizados.
   ```
   {
     "sub": "1234567890",
     "name": "John Doe",
     "admin": true
   }
   ```

3. Firma (Signature): Para garantizar la integridad de los datos transmitidos y evitar que sean modificados, el JWT se firma usando una clave secreta o un par de claves públicas/privadas. La firma se calcula utilizando el encabezado codificado, el cuerpo codificado y una clave secreta (en el caso de HMAC) o la clave privada (en el caso de RSA). La firma se agrega al JWT y se utiliza para verificar su autenticidad cuando se recibe.

Un JWT es autónomo, lo que significa que contiene toda la información necesaria para que el receptor pueda verificar su validez sin necesidad de realizar consultas adicionales a una base de datos o a un servidor de autenticación.

JWT se utiliza comúnmente en aplicaciones web y en sistemas de autenticación basados en tokens. Cuando un usuario inicia sesión en una aplicación web, el servidor genera un JWT y lo devuelve al cliente (por ejemplo, en una cookie o como un encabezado de autorización). El cliente luego incluye este JWT en las solicitudes subsiguientes para autenticarse y acceder a recursos protegidos.

Es importante tener en cuenta que, debido a que el JWT es autocontenido, no se puede revocar una vez emitido, a menos que se utilice una estrategia de corta duración y se renueve periódicamente. Por lo tanto, es fundamental proteger adecuadamente las claves secretas o las claves privadas utilizadas para firmar los JWT y establecer tiempos de expiración razonables para garantizar la seguridad de la aplicación.



<br>
<br>
<br>

## 4 Security en el proyecto

<br>

OAuth 2 (Open Authorization 2.0) es un protocolo de autorización y un estándar abierto que se utiliza para permitir que las aplicaciones accedan a recursos protegidos en nombre de un usuario, sin necesidad de que el usuario comparta sus credenciales de inicio de sesión con la aplicación.

El objetivo principal de OAuth 2 es proporcionar una forma segura y estandarizada de autorizar a aplicaciones de terceros para que accedan a recursos privados en nombre de un usuario, como su información personal, datos de redes sociales, correos electrónicos, fotos, entre otros.

El proceso de autorización en OAuth 2 implica tres roles principales:

1. El propietario del recurso (el usuario): Es la persona o entidad que posee los recursos protegidos y tiene el control sobre ellos.

2. El cliente: Es la aplicación de terceros que desea acceder a los recursos protegidos en nombre del usuario. El cliente debe obtener la autorización del usuario antes de acceder a sus recursos.

3. El servidor de autorización: Es el servidor que emite los tokens de acceso y valida las solicitudes de autorización del cliente en nombre del usuario. Este servidor es responsable de autenticar al usuario y obtener su consentimiento para permitir que el cliente acceda a los recursos.

El flujo de autorización de OAuth 2 generalmente sigue estos pasos:

1. El cliente solicita la autorización al usuario para acceder a sus recursos protegidos.

2. El usuario otorga el consentimiento al cliente para acceder a sus recursos. Este paso puede implicar que el usuario inicie sesión y autentique su identidad.

3. Una vez que el cliente tiene el consentimiento del usuario, envía una solicitud al servidor de autorización para obtener un token de acceso.

4. El servidor de autorización valida la solicitud y, si es exitosa, emite un token de acceso al cliente.

5. El cliente utiliza el token de acceso en las solicitudes subsiguientes para acceder a los recursos protegidos en nombre del usuario.

El token de acceso es un objeto JSON Web Token (JWT) o un token opaco que contiene información sobre el acceso autorizado del cliente a los recursos del usuario. Este token es autónomo y se utiliza para verificar la autorización del cliente en cada solicitud subsiguiente.

OAuth 2 es ampliamente utilizado en aplicaciones web, aplicaciones móviles, servicios API y sistemas distribuidos para garantizar la seguridad y privacidad de los datos del usuario mientras se permite el acceso controlado a los recursos protegidos. Es una solución flexible y segura para la autorización de aplicaciones de terceros sin compartir las credenciales del usuario con cada una de ellas.

![image](https://github.com/crodrigr/microservicios-spring-boot-confenalco/assets/31961588/70facb7b-c53d-4b17-84f2-0ea573080a24)

<br>

### 4.1 Autenticación

![image](https://github.com/crodrigr/microservicios-spring-boot-confenalco/assets/31961588/7866d151-e00d-41fa-b1d3-fa94d7ef1979)

<br>

### 4.2 Autorización 

![image](https://github.com/crodrigr/microservicios-spring-boot-confenalco/assets/31961588/723d9b7d-4dd3-4e8c-990f-547cf9fb73fb)

<br>
<br>
<br>

## 5. Crear Proyecto

Se crea un nuevo proyecto **servicio-oauth**. Este proyecto se va usar la versión **2.5.3** para que se compatible con **spring-security**


![image](https://github.com/crodrigr/microservicios-spring-boot-confenalco/assets/31961588/3bbb1ba9-9060-40ef-9894-c6f38c64aad5)

## 6. Dependencias

Se debe configurar la dependencias adicionando las dependencias de **oauth**, **jwt**, **jaxb** y ajustar la versión **2.5.3**

![image](https://github.com/crodrigr/microservicios-spring-boot-confenalco/assets/31961588/f36dc516-4c62-4195-b23d-4f8f5e453209)



### 6.1 Usuario-commons


Se implementa usuarios, del commons, pero son de tipo entity, y en este proyecto no se van a conectar a la bd, por lo tanto, se desvicula del jpa, hay dos formas de hacer una a através de la anotación **@EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class})** como se hizo en el proyecto de items con producto-commons y esta es la otra forma desde la dependencia con exclusion


![image](https://github.com/crodrigr/microservicios-spring-boot-confenalco/assets/31961588/eb23257b-86c6-4ac5-89fa-fee31ebd82ac)

<br>

<details><summary>Mostrar código</summary>
<p>

```xml

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.5.3</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.comfenalco.microservicios</groupId>
	<artifactId>oauth</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>oauth</name>
	<description>Demo project for Spring Boot</description>
	<properties>
		<java.version>11</java.version>
		<spring-cloud.version>2020.0.3</spring-cloud.version>		
	</properties>
	<dependencies>
	    <dependency>
	       <groupId>com.comfenalco.microservicio.commons</groupId>
	       <artifactId>usuario</artifactId>
	       <version>0.0.1-SNAPSHOT</version>
		   <exclusions>
				<exclusion>
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-starter-data-jpa</artifactId>
				</exclusion>
			</exclusions>
		</dependency>	
	    <dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>	
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.security.oauth</groupId>
			<artifactId>spring-security-oauth2</artifactId>
			<version>2.3.8.RELEASE</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-jwt</artifactId>
			<version>1.1.1.RELEASE</version>
		</dependency>
		<dependency>
			<groupId>org.glassfish.jaxb</groupId>
			<artifactId>jaxb-runtime</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-openfeign</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-config</artifactId>
		</dependency>
	</dependencies>
	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>${spring-cloud.version}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>

</project>




```


</p>
</details>

<br>
<br>
<br>

## 7. Eureka 

Se coloca la anotación  **@EnableDiscoveryClient** colocar como cliente de **eureka**

![image](https://github.com/crodrigr/microservicios-spring-boot-confenalco/assets/31961588/89ce4134-fdda-4af6-a714-9483be26e3d8)

<br>

### 7.1 application.properties



Configuración del proyecto en **application.properties**

![image](https://github.com/crodrigr/microservicios-spring-boot-confenalco/assets/31961588/b7046da1-6331-48df-bb2b-78aedcf96d9e)



La propiedad **spring.config.import=optional:configserver** se puede agregar en el archivo bootstrap.properties o bootstrap.yml (o en el archivo application.properties o application.yml si no se utiliza el archivo bootstrap) de una aplicación Spring Boot. Esta configuración indica a la aplicación que debe intentar importar la configuración desde un servidor de configuración, si está disponible, pero si el servidor de configuración no está disponible o no se encuentra, la aplicación continuará con su configuración local.

<br>

## 8. Feing

En **SpringbootServicioOauthApplication** colocamos la antoción **@EnableFeignClients** para implementar **feing**

![image](https://github.com/crodrigr/microservicios-spring-boot-confenalco/assets/31961588/077600b2-8795-48cf-aa39-4e238a11ae9c)

### 8.1 UsuarioFeignClient

Se crea un cliente feing de Usuario para consumir los servicios **/usuarios/search/buscar-username** y **/usuarios/{id}** que están en el proyecto **servicio-usuarios**. Esto también se podría hacer con **RestTemplate**

<br>

![image](https://github.com/crodrigr/microservicios-spring-boot-confenalco/assets/31961588/915883c9-3b95-4106-9386-c1a3b0b07a9d)

<br>

### 8.1 UsuarioService

![image](https://github.com/crodrigr/microservicios-spring-boot-confenalco/assets/31961588/5310a348-a5c2-4b01-ac59-5182adaaf171)

<br>

El código proporcionado es un método que implementa la interfaz `UserDetailsService` de Spring Security. La función de este método es cargar los detalles del usuario (como roles y permisos) a partir de un servicio externo o base de datos para su autenticación y autorización dentro de la aplicación.

Aquí está una explicación paso a paso del código:

1. El método `loadUserByUsername` recibe el nombre de usuario (`username`) como parámetro y devuelve un objeto `UserDetails`, que representa los detalles del usuario requeridos por Spring Security.

2. El método comienza intentando recuperar el objeto `Usuario` (entidad de usuario) correspondiente al nombre de usuario proporcionado llamando al método `findByUsername` del cliente Feign (`client`). Feign es una biblioteca de cliente HTTP declarativa que se utiliza aquí para hacer la llamada a un servicio externo o API que proporciona detalles del usuario.

3. Si el usuario se encuentra exitosamente en el sistema, se procede a crear una lista de `GrantedAuthority`, que representa los roles del usuario. Se mapean los roles de la entidad `Usuario` a `SimpleGrantedAuthority` utilizando `map` y luego se recopilan en una lista usando `collect`.

4. La operación `peek` se utiliza para imprimir en el registro (logs) los nombres de los roles de cada usuario, esto es útil para propósitos de depuración y para ver qué roles se están asignando al usuario.

5. Se crea una instancia de `User` (clase proporcionada por Spring Security) que implementa la interfaz `UserDetails`. Esta instancia representa los detalles del usuario y se utiliza para la autenticación en Spring Security.

6. Finalmente, el método devuelve el objeto `User` que contiene el nombre de usuario, contraseña, estado de habilitación y roles del usuario, lo que permitirá que Spring Security realice la autenticación y autorización adecuadas.

7. En caso de que ocurra una excepción de tipo `FeignException` (por ejemplo, si el usuario no se encuentra en el sistema), se captura la excepción, se registra un mensaje de error y se relanza una excepción de tipo `UsernameNotFoundException`. Esta excepción indica que el usuario no se encontró y se utiliza para que Spring Security maneje adecuadamente la autenticación fallida.

En general, este método es responsable de cargar los detalles del usuario a partir del nombre de usuario proporcionado y preparar los detalles del usuario en un formato adecuado para que Spring Security pueda llevar a cabo la autenticación y autorización en la aplicación.

### 8.2 UsuarioServiceImpl

![image](https://github.com/crodrigr/microservicios-spring-boot-confenalco/assets/31961588/7d3b602b-e7cb-440d-90f6-99cbc66757db)

<details><summary>Mostrar código</summary>
<p>

```java
package com.comfenalco.microservicios.oauth.services;

import java.util.List;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import com.comfenalco.microservicio.commons.usuario.models.entities.Usuario;
import com.comfenalco.microservicios.oauth.clients.UsuarioFeignClient;

import feign.FeignException;

@Service
public class UsuarioServiceImpl implements UsuarioService, UserDetailsService {

	private Logger log = LoggerFactory.getLogger(UsuarioServiceImpl.class);

	@Autowired 	        
	private UsuarioFeignClient client;

	@Override
	public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {

		try {
			Usuario usuario = client.findByUsername(username);

			List<GrantedAuthority> authorities = usuario.getRoles().stream()
					.map(role -> new SimpleGrantedAuthority(role.getNombre()))
					.peek(authority -> log.info("Role: ".concat(authority.getAuthority()))).collect(Collectors.toList());

           
			log.info("Usuario autenticado: ".concat(username));
            

			return new User(usuario.getUsername(), usuario.getPassword(), usuario.getEnabled(), true, true, true,
					authorities);

		} catch (FeignException e) {
			String error = "Error en el login, no existe el usuario '" + username + "' en el sistema";
			log.error(error);

			throw new UsernameNotFoundException(error);
		}
	}

	@Override
	public Usuario findByUsername(String username) {
		return client.findByUsername(username);
	}

	@Override
	public Usuario update(Usuario usuario, Long id) {
		return client.update(usuario, id);
	}

  


}



```

</p>
</details>

<br>
<br>
<br>

## 9. SpringSecurityConfig

<br>

![image](https://github.com/crodrigr/microservicios-spring-boot-confenalco/assets/31961588/a2467602-f158-4f4a-af5a-758242fbcb50)

<details><summary>Mostrar código</summary>
<p>

 ```java
package com.comfenalco.microservicios.oauth.security;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationEventPublisher;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

@Configuration
public class SpringSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
	private UserDetailsService usuarioService;
	
	@Autowired
	private AuthenticationEventPublisher eventPublisher;
	
	@Bean
	public BCryptPasswordEncoder passwordEncoder() {
		return new BCryptPasswordEncoder();
	}

	@Override
	@Autowired
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		auth.userDetailsService(this.usuarioService).passwordEncoder(passwordEncoder())
		.and().authenticationEventPublisher(eventPublisher);
	}

	@Override
	@Bean
	protected AuthenticationManager authenticationManager() throws Exception {
		return super.authenticationManager();
	}
	
	
    
}


```


</p>
</details>

<br>

Este código muestra una configuración de seguridad básica usando Spring Security en una aplicación Spring Boot. Aquí se extiende la clase `WebSecurityConfigurerAdapter` para personalizar la configuración de seguridad. A continuación, se explican los elementos clave del código:

1. `@Configuration`: Esta anotación indica que esta clase es una clase de configuración de Spring.

2. `SpringSecurityConfig`: Es el nombre de la clase de configuración que extiende `WebSecurityConfigurerAdapter`.

3. `@Autowired`: Esta anotación se utiliza para inyectar (autocablear) dependencias en la clase. En este caso, se inyectan las instancias de `UserDetailsService` y `AuthenticationEventPublisher`.

4. `UserDetailsService`: Es una interfaz proporcionada por Spring Security que se utiliza para cargar los detalles del usuario a partir del nombre de usuario durante la autenticación.

5. `AuthenticationEventPublisher`: Es una interfaz proporcionada por Spring Security que se utiliza para publicar eventos de autenticación, como inicio de sesión exitoso o fallido.

6. `BCryptPasswordEncoder`: Es un `@Bean` que crea un codificador de contraseñas basado en el algoritmo BCrypt. Este codificador se utilizará para cifrar las contraseñas de los usuarios en la base de datos.

7. `configure(AuthenticationManagerBuilder auth)`: Este método se anula para configurar el `AuthenticationManager`. Aquí se configura el `UserDetailsService` para la autenticación y el codificador de contraseñas. También se configura el `AuthenticationEventPublisher` para manejar eventos de autenticación.

8. `authenticationManager()`: Este método se anula para exponer el `AuthenticationManager` como un `@Bean`. Esto es útil cuando necesitas inyectar el `AuthenticationManager` en otras partes de la aplicación.

Con esta configuración, Spring Security estará habilitado en tu aplicación y se utilizará el `UserDetailsService` para autenticar a los usuarios y el codificador `BCryptPasswordEncoder` para cifrar y comparar las contraseñas almacenadas en la base de datos. Además, los eventos de autenticación serán manejados por el `AuthenticationEventPublisher`.

Es importante mencionar que esta configuración básica es solo el punto de partida y puede requerir ajustes adicionales dependiendo de los requisitos de seguridad específicos de tu aplicación. Por ejemplo, puedes configurar reglas de autorización, manejar autenticación basada en tokens (por ejemplo, OAuth 2.0), entre otras funcionalidades de seguridad más avanzadas.

<br>
<br>
<br>

## 11. InfoAdicionalToken

![image](https://github.com/crodrigr/microservicios-spring-boot-confenalco/assets/31961588/199027cf-94b8-42b4-8b82-546a086f9080)

El código que proporcionas muestra una clase llamada `InfoAdicionalToken` que implementa la interfaz `TokenEnhancer`. Esta clase se utiliza para agregar información adicional a un token de acceso OAuth2 al momento de generarse.

A continuación, explicaré cada parte del código:

1. `@Component`: Esta anotación indica que la clase `InfoAdicionalToken` es un componente de Spring y se debe registrar en el contexto de la aplicación. Esto permite que Spring maneje la inyección de dependencias y otras funcionalidades relacionadas con la gestión de componentes.

2. `UsuarioService`: Esta es una dependencia de la clase `InfoAdicionalToken`. Se inyecta automáticamente usando la anotación `@Autowired`. La clase `UsuarioService` probablemente es una interfaz o clase que proporciona métodos para obtener información del usuario, como su nombre, apellido y correo electrónico.

3. `TokenEnhancer`: Esta es una interfaz proporcionada por Spring Security OAuth2 que se utiliza para mejorar (enhance) el token de acceso OAuth2. La interfaz define un método `enhance` que permite agregar información adicional al token.

4. `enhance`: Este es el método implementado de la interfaz `TokenEnhancer`. En este método, se obtiene el objeto `Usuario` correspondiente al usuario autenticado mediante el servicio `usuarioService`. Luego, se crea un mapa (`info`) que contiene información adicional que se desea agregar al token. En este caso, se agregan el nombre, apellido y correo electrónico del usuario.

5. `((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(info)`: Aquí se establece la información adicional en el token de acceso OAuth2. El token de acceso recibido como parámetro (`accessToken`) se convierte a `DefaultOAuth2AccessToken` (una implementación de `OAuth2AccessToken`), y luego se agrega la información adicional (`info`) al token utilizando el método `setAdditionalInformation`.

En resumen, esta clase `InfoAdicionalToken` actúa como un `TokenEnhancer` personalizado que agrega información adicional al token de acceso OAuth2, como el nombre, apellido y correo electrónico del usuario autenticado. Esto es útil cuando deseas incluir información adicional en el token para que esté disponible para los clientes que lo utilizan en sus solicitudes a recursos protegidos.

<details><summary>Mostrar código</summary>
<p>

 ```java
package com.comfenalco.microservicios.oauth.security;

import java.util.HashMap;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.oauth2.common.DefaultOAuth2AccessToken;
import org.springframework.security.oauth2.common.OAuth2AccessToken;
import org.springframework.security.oauth2.provider.OAuth2Authentication;
import org.springframework.security.oauth2.provider.token.TokenEnhancer;
import org.springframework.stereotype.Component;

import com.comfenalco.microservicio.commons.usuario.models.entities.Usuario;
import com.comfenalco.microservicios.oauth.services.UsuarioService;

@Component
public class InfoAdicionalToken implements TokenEnhancer{

	@Autowired
	private UsuarioService usuarioService;
	
	@Override
	public OAuth2AccessToken enhance(OAuth2AccessToken accessToken, OAuth2Authentication authentication) {
		Map<String, Object> info = new HashMap<String, Object>();
		
		Usuario usuario = usuarioService.findByUsername(authentication.getName());
		info.put("nombre", usuario.getNombre());
		info.put("apellido", usuario.getApellido());
		info.put("correo", usuario.getEmail());
		((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(info);
		
		return accessToken;
	}

}


```


</p>
</details>


<br>
<br>
<br>

## 12. AuthorizationServerConfig

![image](https://github.com/crodrigr/microservicios-spring-boot-confenalco/assets/31961588/374b01b8-2756-4626-8b63-7e9980445b3b)

<details><summary>Mostrar código</summary>
<p>

 ```java
package com.comfenalco.microservicios.oauth.security;

import java.util.Arrays;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;
import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;
import org.springframework.security.oauth2.provider.token.TokenEnhancerChain;
import org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;
import org.springframework.security.oauth2.provider.token.store.JwtTokenStore;

@RefreshScope
@Configuration
@EnableAuthorizationServer
public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {

    @Autowired
	private Environment env;

	@Autowired
	private BCryptPasswordEncoder passwordEncoder;
	
	@Autowired
	private AuthenticationManager authenticationManager;
	
	@Autowired
	private InfoAdicionalToken infoAdicionalToken;

	@Override
	public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
		security.tokenKeyAccess("permitAll()")
		.checkTokenAccess("isAuthenticated()");
	}

	@Override
	public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
		clients.inMemory().withClient(env.getProperty("config.security.oauth.client.id"))
		.secret(passwordEncoder.encode(env.getProperty("config.security.oauth.client.secret")))
		.scopes("read", "write")
		.authorizedGrantTypes("password", "refresh_token")
		.accessTokenValiditySeconds(3600)
		.refreshTokenValiditySeconds(3600);
	}

	@Override
	public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
		
		TokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain();
		tokenEnhancerChain.setTokenEnhancers(Arrays.asList(infoAdicionalToken, accessTokenConverter()));
		
		endpoints.authenticationManager(authenticationManager)
		.tokenStore(tokenStore())
		.accessTokenConverter(accessTokenConverter())
		.tokenEnhancer(tokenEnhancerChain);
	}

	@Bean
	public JwtTokenStore tokenStore() {
		return new JwtTokenStore(accessTokenConverter());
	}

	@Bean
	public JwtAccessTokenConverter accessTokenConverter() {
		JwtAccessTokenConverter tokenConverter = new JwtAccessTokenConverter();
		tokenConverter.setSigningKey(env.getProperty("config.security.oauth.jwt.key"));
		return tokenConverter;
	}
	
    
}


```


</p>
</details>

<br>

El código que proporcionas es una configuración básica de un servidor de autorización (Authorization Server) usando Spring Security y OAuth2. A continuación, explicaré cada parte del código:

1. `@RefreshScope`: Esta anotación se usa en la clase de configuración para habilitar el refrescamiento dinámico de propiedades. Permite que los beans anotados se actualicen automáticamente si hay cambios en las propiedades externas. Esto es útil para configuraciones que pueden cambiar sin tener que reiniciar la aplicación.

2. `@Configuration`: Esta anotación indica que la clase `AuthorizationServerConfig` es una clase de configuración de Spring.

3. `@EnableAuthorizationServer`: Esta anotación habilita la funcionalidad del servidor de autorización en la aplicación. Es una anotación clave para configurar un servidor de autorización OAuth2.

4. `Environment`: Es una interfaz de Spring que proporciona acceso a las propiedades del entorno de la aplicación. Se utiliza para obtener los valores de configuración de las propiedades externas que se utilizan en la configuración del servidor de autorización.

5. `BCryptPasswordEncoder`: Es una clase que implementa `PasswordEncoder` y se utiliza para cifrar y comparar contraseñas. Se utiliza para cifrar el secreto del cliente OAuth2 en la configuración de clientes.

6. `AuthenticationManager`: Es una interfaz de Spring Security que se utiliza para autenticar las solicitudes de acceso al servidor de autorización.

7. `InfoAdicionalToken`: Es una clase personalizada que implementa `TokenEnhancer` (como se explicó en una respuesta anterior). Se utiliza para agregar información adicional al token de acceso OAuth2.

8. `configure(AuthorizationServerSecurityConfigurer security)`: Este método configura la seguridad del servidor de autorización. En este caso, se permite el acceso público al endpoint `/oauth/token_key` para obtener la clave pública utilizada para verificar la firma del token y se requiere autenticación para acceder al endpoint `/oauth/check_token`.

9. `configure(ClientDetailsServiceConfigurer clients)`: Este método configura los detalles del cliente (clients) que pueden acceder al servidor de autorización. En este caso, se configura un cliente in-memory con ID y secreto específicos, alcances permitidos y tipos de concesión autorizados (password y refresh_token).

10. `configure(AuthorizationServerEndpointsConfigurer endpoints)`: Este método configura los endpoints del servidor de autorización. Aquí se define el `AuthenticationManager`, el `JwtTokenStore` y el `JwtAccessTokenConverter` que se utilizarán para generar y manejar los tokens de acceso OAuth2. También se agrega el `InfoAdicionalToken` personalizado al `TokenEnhancerChain` para agregar información adicional al token de acceso.

11. `tokenStore()`: Este método crea una instancia de `JwtTokenStore` que utiliza el `JwtAccessTokenConverter` para manejar los tokens de acceso en formato JWT (JSON Web Token).

12. `accessTokenConverter()`: Este método crea una instancia de `JwtAccessTokenConverter` que se utiliza para convertir los tokens de acceso a formato JWT y viceversa. Se establece la clave de firma (`signingKey`) obtenida de las propiedades del entorno de la aplicación.

En resumen, esta clase `AuthorizationServerConfig` configura un servidor de autorización OAuth2 con un cliente in-memory, utiliza JWT como formato de token de acceso y agrega información adicional al token de acceso mediante un `TokenEnhancer` personalizado. Esta configuración proporciona una implementación básica de un servidor de autorización OAuth2 en una aplicación Spring Boot.



<br>
<br>
<br>

## 13 Configuracion 

### 13.1 Local

![image](https://github.com/crodrigr/microservicios-spring-boot-confenalco/assets/31961588/a6db8a53-033a-421c-bb6c-406a467af1e1)

<br>

### 13.2 Server config

<br>

![image](https://github.com/crodrigr/microservicios-spring-boot-confenalco/assets/31961588/ec797767-75e3-4a7e-9f18-f250abca7e1e)

<br>

![image](https://github.com/crodrigr/microservicios-spring-boot-confenalco/assets/31961588/44609554-3888-4552-9bba-2759323ba08e)

<br>

![image](https://github.com/crodrigr/microservicios-spring-boot-confenalco/assets/31961588/a37a7060-4808-4636-ab71-8303f3861196)

<br>
<br>
<br>

## 14. Zuul

Cuando se combina Zuul con OAuth 2.0, se puede lograr una autenticación y autorización centralizada para las solicitudes que atraviesan el gateway. De esta manera, el gateway se convierte en un punto único de entrada y salida para las solicitudes y puede proteger los microservicios detrás de él.

### 14.1 Dependencias

Se agregan las dependencias: **oauth2**, **jwt**, y **jaxb**

![image](https://github.com/crodrigr/microservicios-spring-boot-confenalco/assets/31961588/81d028b4-56ad-4a5d-8d92-feddfc8d6c24)

<details><summary>Mostrar código</summary>
<p>

 ```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.3.12.RELEASE</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.comfenalco.microservicios</groupId>
	<artifactId>zuul</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>zuul</name>
	<description>Demo project for Spring Boot</description>
	<properties>
		<java.version>11</java.version>
		<spring-cloud.version>Hoxton.SR12</spring-cloud.version>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-zuul</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.security.oauth</groupId>
			<artifactId>spring-security-oauth2</artifactId>
			<version>2.3.8.RELEASE</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-jwt</artifactId>
			<version>1.1.1.RELEASE</version>
		</dependency>
		<dependency>
			<groupId>org.glassfish.jaxb</groupId>
			<artifactId>jaxb-runtime</artifactId>
		</dependency>
	</dependencies>
	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>${spring-cloud.version}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>

</project>


```


</p>
</details>

<br>
<br>
<br>


### 14.2 ResourceServerConfig


![image](https://github.com/crodrigr/microservicios-spring-boot-confenalco/assets/31961588/809d0759-2197-4439-89a5-f6da4e5b746e)

El código que proporcionas es una configuración de seguridad para un servidor de recursos (Resource Server) en una aplicación que utiliza OAuth 2.0 y JWT (JSON Web Tokens) para autenticar y autorizar las solicitudes entrantes. A continuación, se explica cada parte del código:

1. `@RefreshScope`: Esta anotación se utiliza para permitir el refrescamiento dinámico de las propiedades. Permite que las propiedades anotadas con `@Value` se actualicen automáticamente si cambian en tiempo de ejecución.

2. `@Configuration`: Esta anotación indica que la clase `ResourceServerConfig` es una clase de configuración de Spring.

3. `@EnableResourceServer`: Esta anotación habilita el servidor de recursos (Resource Server) en la aplicación. Es una anotación clave para configurar un servidor de recursos OAuth 2.0.

4. `@Value("${config.security.oauth.jwt.key}")`: Esta anotación se utiliza para inyectar el valor de la propiedad `config.security.oauth.jwt.key` desde las propiedades de la aplicación. La propiedad representa la clave secreta utilizada para firmar y verificar los tokens JWT.

5. `configure(ResourceServerSecurityConfigurer resources)`: Este método configura la seguridad del servidor de recursos. Aquí se establece el `JwtTokenStore` como el mecanismo de almacenamiento de tokens utilizado para validar los tokens de acceso JWT.

6. `configure(HttpSecurity http)`: Este método configura las reglas de autorización para las solicitudes entrantes. En este caso, se definen reglas de autorización basadas en rutas URL y roles de usuario. Por ejemplo, algunas rutas se permiten a todos los usuarios (`permitAll()`), mientras que otras requieren roles específicos como `ADMIN` o `USER`. También se configura la política CORS para permitir solicitudes desde cualquier origen y se agregan las cabeceras `Authorization` y `Content-Type` como cabeceras permitidas en las solicitudes CORS.

7. `corsConfigurationSource()`: Este método configura la política CORS que permite que las solicitudes de cualquier origen y métodos HTTP (POST, GET, PUT, DELETE, OPTIONS) sean aceptadas por el servidor de recursos. Además, se establece `Allow-Credentials` como `true` para permitir que el servidor de recursos responda a solicitudes CORS con credenciales (como cookies o autenticación HTTP).

8. `corsFilter()`: Este método crea y registra un filtro CORS con una alta prioridad (`Ordered.HIGHEST_PRECEDENCE`) para asegurarse de que el filtro CORS se aplique antes de otros filtros de seguridad.

9. `tokenStore()`: Este método crea una instancia de `JwtTokenStore`, que se utiliza para almacenar y validar tokens de acceso JWT.

10. `accessTokenConverter()`: Este método crea una instancia de `JwtAccessTokenConverter`, que se utiliza para convertir tokens de acceso entre formato JWT y su representación interna.

En resumen, esta configuración establece un servidor de recursos (Resource Server) que protege las rutas URL de la aplicación según reglas de autorización basadas en roles de usuario. También configura la política CORS para permitir solicitudes desde cualquier origen y establece un mecanismo de almacenamiento y conversión de tokens JWT. Esta configuración es útil cuando se desea implementar la autenticación y autorización centralizada en una aplicación Spring Boot que utiliza OAuth 2.0 y JWT.

<details><summary>Mostrar código</summary>
<p>

 ```java
package com.comfenalco.microservicios.zuul.oauth;

import java.util.Arrays;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.Ordered;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;
import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;
import org.springframework.security.oauth2.config.annotation.web.configurers.ResourceServerSecurityConfigurer;
import org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter;
import org.springframework.security.oauth2.provider.token.store.JwtTokenStore;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

@RefreshScope
@Configuration
@EnableResourceServer
public class ResourceServerConfig extends ResourceServerConfigurerAdapter {

    @Value("${config.security.oauth.jwt.key}")
	private String jwtKey;
	
	@Override
	public void configure(ResourceServerSecurityConfigurer resources) throws Exception {
		resources.tokenStore(tokenStore());
	}

	@Override
	public void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests(requests -> requests.antMatchers("/api/security/oauth/**").permitAll()
                .antMatchers(HttpMethod.GET, "/api/productos/listar", "/api/items/listar", "/api/usuarios/usuarios").permitAll()
                .antMatchers(HttpMethod.GET, "/api/productos/ver/{id}",
                        "/api/items/ver/{id}/cantidad/{cantidad}",
                        "/api/usuarios/usuarios/{id}").hasAnyRole("ADMIN", "USER")
                .antMatchers("/api/productos/**", "/api/items/**", "/api/usuarios/**").hasRole("ADMIN")
                .anyRequest().authenticated()).cors(cors -> cors.configurationSource(corsConfigurationSource()));
	}
	
	@Bean
	public CorsConfigurationSource corsConfigurationSource() {
		CorsConfiguration corsConfig = new CorsConfiguration();
		corsConfig.setAllowedOrigins(Arrays.asList("*"));
		corsConfig.setAllowedMethods(Arrays.asList("POST", "GET", "PUT", "DELETE", "OPTIONS"));
		corsConfig.setAllowCredentials(true);
		corsConfig.setAllowedHeaders(Arrays.asList("Authorization", "Content-Type"));
		
		UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
		source.registerCorsConfiguration("/**", corsConfig);
		
		return source;
	}
	
	@Bean
	public FilterRegistrationBean<CorsFilter> corsFilter(){
		FilterRegistrationBean<CorsFilter> bean = new FilterRegistrationBean<CorsFilter>(new CorsFilter(corsConfigurationSource()));
		bean.setOrder(Ordered.HIGHEST_PRECEDENCE);
		return bean;
	}
	
	@Bean
	public JwtTokenStore tokenStore() {
		return new JwtTokenStore(accessTokenConverter());
	}

	@Bean
	public JwtAccessTokenConverter accessTokenConverter() {
		JwtAccessTokenConverter tokenConverter = new JwtAccessTokenConverter();
		tokenConverter.setSigningKey(jwtKey);
		return tokenConverter;
	}

    
}


```


</p>
</details>

<br>
<br>
<br>



![image](https://github.com/crodrigr/microservicios-spring-boot-confenalco/assets/31961588/857dda69-7015-4bca-92a2-a8bdfb5e4fb0)

